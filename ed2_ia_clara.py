# -*- coding: utf-8 -*-
"""ED2_IA_CLARA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DLSKjoYKfP-hTahFkfqLv74x-f1YrkLk
"""

import numpy as np
import math
import matplotlib.pyplot as plt
from IPython.display import HTML
from matplotlib import animation, rc

"""# Classe Labirinto

"""

class Labirinto:

  def __init__(self,dim=10):

    # Inicializando o labirinto. Nele, vamos considerar que todas as celulas sao paredes
    self.labirintoPlot    =  np.zeros((dim,dim,3), dtype=np.int64)
    self.labirintoArestas =  np.zeros((dim,dim), dtype=np.int64)
    self.dim = dim

    # Selecionar uma celula parede do labirinto como ponto inicial. Com a selecao abaixo,
    # o labirinto sempre tera seu inicio no canto esquerdo do grafico
    posicaoInicial = np.random.randint(0, (dim-1))


    fronteira = []
    fronteira.append((posicaoInicial,0))
    dx = [ 0, 1, 0, -1] # Movimentacao de x
    dy = [-1, 0, 1,  0] # movimentacao de y

    while fronteira != []:
      # Transformar a celula (parede) do labirinto em uma celula valida
      (vx, vy) = fronteira[-1] # Selecionando o ultimo elemento da lista
      self.labirintoArestas[vx,vy] = 1

      # verificar se a celula (parede) possui somente um vizinho que nao seja parede
      # caso sim, podemos incluir ela como uma passagem.
      vizinhosNaoVisitados=[]

      # Consideramos que a celula tem vizinhos acima, abaixo a esquerda e a direita.
      # Para isso, utilizamos as listas dx e dy para determinar essas posicoes
      for i in range(4):
        nx = vx + dx[i]
        ny = vy + dy[i]

        if nx >=0 and nx < dim and ny >=0 and ny < dim:
          if self.labirintoArestas[nx, ny] == 0:

            confereVizinho=0
            for j in range(4):
              ex = nx + dx[j]
              ey = ny + dy[j]

              if ex >=0 and ex < dim and ey >=0 and ey < dim:
                if self.labirintoArestas[ex, ey] == 1:
                  confereVizinho +=1

            if confereVizinho == 1:
              vizinhosNaoVisitados.append(i)

      if len(vizinhosNaoVisitados) > 0:
        irPara= np.random.choice(vizinhosNaoVisitados)
        vx += dx[irPara]
        vy += dy[irPara]
        fronteira.append((vx,vy))
      else:
        fronteira.pop()

    # Ajustar a posicao final (considerando um ponto do lado direito do labirinto)
    encontrou= False
    while not encontrou:
      posicaoFinal = np.random.randint(0,(dim-1))
      if self.labirintoArestas[posicaoFinal, dim-1] ==1:
        encontrou=True


    # Colorir Labirinto
    self.labirintoPlot[:,:, 0] += 255* self.labirintoArestas
    self.labirintoPlot[:,:, 1] += 255* self.labirintoArestas
    self.labirintoPlot[:,:, 2] += 255* self.labirintoArestas

    # Colorir posicao inicial e final
    self.labirintoPlot[posicaoInicial,0,1] = 0
    self.labirintoPlot[posicaoInicial,0,2] = 0

    self.labirintoPlot[posicaoFinal,dim-1, 0] = 0
    self.labirintoPlot[posicaoFinal,dim-1, 1] = 0

    # Armazenar no objeto as posicoes inicial e final do labirinto
    self.posicaoInicial = (posicaoInicial,0)
    self.posicaoFinal = (posicaoFinal,dim-1)

  def getLabirintoPlot(self, posicoes=None, cores=(255,0,0)):
    if posicoes==None:
      return self.labirintoPlot

    resposta = self.labirintoPlot.copy()
    for t in posicoes:
      for camada in range(3):
        resposta[t[0],t[1],camada] = cores[camada]
    return resposta


  def getPosicaoInicio(self):
    return self.posicaoInicial


  def getDestino(self):
    return self.posicaoFinal

class Node():
  # Constructor for Node class.
  def __init__(self, pai=None, pos=None):
    self.pai = pai
    self.pos = pos

    self.g = self.h = self.f = 0

"""# Funções auxiliares. Serão utilizadas para exibição dos nós visitados no labirinto"""

def getVizinhos(celula):
  linha = celula[0]
  col = celula[1]

  emCima = (linha - 1, col)
  emBaixo = (linha + 1, col)
  dir = (linha, col + 1)
  esq = (linha, col - 1)

  if linha == 0:
    if col == 0:
      vizinhos = (dir, emBaixo)
    elif col == 9:
      vizinhos = (esq, emBaixo)
    else:
      vizinhos = (dir, esq, emBaixo)
  elif linha == 9:
    if col == 0:
      vizinhos = (dir, emCima)
    elif col == 9:
      vizinhos = (esq, emCima)
    else:
      vizinhos = (dir, esq, emCima)
  elif col == 9:
    if linha == 9:
      vizinhos = (esq, emCima)
    else:
      vizinhos = (esq, emCima, emBaixo)
  elif col == 0:
    vizinhos = (dir, emCima, emBaixo)
  else:
    vizinhos = (dir, esq, emCima, emBaixo)
  return vizinhos

def matrizDistanciaEuclidiana():
  dim = labirinto.dim
  distancias = np.zeros((dim,dim), dtype=np.float32)

  for linha in range(0,dim):
    for col in range(0, dim):
      a = linha - labirinto.getDestino()[0]
      b = col - labirinto.getDestino()[1]
      #Distância euclidiana
      dist = math.sqrt(math.pow(a, 2) + math.pow(b, 2))
      distancias[linha][col] = dist
  return distancias

"""# Definição dos algoritmos de busca

## Busca em largura
"""

def buscaEmLargura(labirinto):

  fronteira = [] # lista vazia
  fronteiraNode = []
  caminhos = []
  celulasVisitadas = []
  statusLabirinto = []

  fig, ax = plt.subplots()
  ims = []
  ims.append([ax.imshow(labirinto.getLabirintoPlot())])

  srcNode = Node(None, labirinto.getPosicaoInicio())
  destNode = Node(None, labirinto.getDestino())

  fronteira.append(labirinto.getPosicaoInicio())
  fronteiraNode.append(srcNode)

  while fronteira != []:
    # Imprime Fronteira
    statusLabirinto.append(labirinto.getLabirintoPlot(posicoes=fronteira, cores=(0,255,127)))

    # Selecionando o primeiro elemento da lista
    celula = fronteira.pop(0)
    celulasVisitadas.append(celula)
    caminhos.append(celula)

    im = ax.imshow(statusLabirinto[statusLabirinto.__len__() - 1])
    ims.append([im])

    if celula == labirinto.getDestino():
      print("Objetivo", celula, "encontrado")

      """path = []
      noAtual = fronteiraNode.pop()

      while noAtual is not None:
        path.append(noAtual.pos)
        noAtual = noAtual.pai

      caminhoEncontrado = path[::-1]
      #caminhoEncontrado = selecionaCaminho(caminhos, labirinto.getDestino())## Guia para implementar
      statusLabirinto.append(labirinto.getLabirintoPlot(posicoes=caminhoEncontrado, cores=(0,0,255)))"""

      im = ax.imshow(statusLabirinto[statusLabirinto.__len__() - 1])
      ims.append([im])
      ani = animation.ArtistAnimation(fig, ims, interval=500, blit=True, repeat_delay=10000)
      plt.show()

      return

    else:
      vizinhos = getVizinhos(celula)
      for vizinho in vizinhos:
        if vizinho not in celulasVisitadas:
          if labirinto.labirintoArestas[vizinho] != 0:
            fronteira.append(vizinho)
            fronteiraNode.append(Node(celula, vizinho))

  print("Objetivo nao existente no grafo")

"""## Busca em profundidade"""

def buscaEmProfundidade(labirinto):

  fronteira = []
  fronteiraNode = []
  caminhos = []
  celulasVisitadas = []
  statusLabirinto = []

  fig, ax = plt.subplots()
  ims = []
  ims.append([ax.imshow(labirinto.getLabirintoPlot())])

  srcNode = Node(None, labirinto.getPosicaoInicio())
  destNode = Node(None, labirinto.getDestino())

  fronteira.append(labirinto.getPosicaoInicio())
  fronteiraNode.append(srcNode)

  while fronteira != []:
    # Imprime Fronteira
    statusLabirinto.append(labirinto.getLabirintoPlot(posicoes=fronteira, cores=(0,255,127)))

    # Selecionando o último elemento da lista
    celula = fronteira.pop()
    celulasVisitadas.append(celula)
    caminhos.append(celula)

    im = ax.imshow(statusLabirinto[len(statusLabirinto) - 1])
    ims.append([im])

    if celula == labirinto.getDestino():
      print("Objetivo", celula, "encontrado")

      """path = []
      noAtual = fronteiraNode.pop()
      print(noAtual.pos)

      while noAtual is not None:
        path.append(noAtual.pos)
        noAtual = noAtual.pai

      caminhoEncontrado = path[::-1]
      #caminhoEncontrado = selecionaCaminho(caminhos, labirinto.getDestino())## Guia para implementar
      statusLabirinto.append(labirinto.getLabirintoPlot(posicoes=caminhoEncontrado, cores=(0,0,255)))"""

      im = ax.imshow(statusLabirinto[len(statusLabirinto) - 1])
      ims.append([im])
      ani = animation.ArtistAnimation(fig, ims, interval=300, blit=True, repeat = True)
      plt.show()

      return

    else:
      vizinhos = getVizinhos(celula)
      for vizinho in vizinhos:
        if vizinho not in celulasVisitadas:
          if labirinto.labirintoArestas[vizinho] != 0:
            fronteira.append(vizinho)
            fronteiraNode.append(Node(celula, vizinho))

  print("Objetivo nao existente no grafo")

"""##Best first"""

def bestFirst(labirinto):

  fronteiraNode = []
  fronteira = []
  celulasVisitadas = []
  statusLabirinto = []
  matrizDist = matrizDistanciaEuclidiana()

  fig, ax = plt.subplots()
  ims = []
  ims.append([ax.imshow(labirinto.getLabirintoPlot())])

  srcNode = Node(None, labirinto.getPosicaoInicio())
  destNode = Node(None, labirinto.getDestino())

  fronteiraNode.append(srcNode)
  fronteira.append(labirinto.getPosicaoInicio())

  while fronteiraNode != []:
    # Imprime Fronteira
    statusLabirinto.append(labirinto.getLabirintoPlot(posicoes=fronteira, cores=(0,255,127)))
    noAtual = fronteiraNode[0]
    indiceAtual = 0

    #Encontra o nó com a menor distancia
    for index, item in enumerate(fronteiraNode):
      if matrizDist[item.pos] < matrizDist[noAtual.pos]:
        noAtual = item
        indiceAtual = index

    # Selecionando o menor elemento da lista
    fronteiraNode.pop(indiceAtual)
    celulasVisitadas.append(noAtual)

    im = ax.imshow(statusLabirinto[statusLabirinto.__len__() - 1])
    ims.append([im])

    if noAtual.pos == destNode.pos:
      print("Objetivo", noAtual.pos, "encontrado")

      #Seleciona o caminho do nó inicial até o objetivo
      path = []
      no = noAtual
      while no is not None:
        path.append(no.pos)
        no = no.pai
      caminhoEncontrado = path[::-1]

      #Imprime animação para o caminho final
      statusLabirinto.append(labirinto.getLabirintoPlot(posicoes=caminhoEncontrado, cores=(0,0,255)))
      im = ax.imshow(statusLabirinto[len(statusLabirinto) - 1])
      ims.append([im])
      ani = animation.ArtistAnimation(fig, ims, interval=300, blit=True, repeat = True)
      plt.show()

      return path[::-1]

    else:
      vizinhos = getVizinhos(noAtual.pos)

      #BFS
      nosAdjacentes = []
      jaVisitado = []
      i = 0
      for vizinho in vizinhos:
        nosAdjacentes.append(Node(noAtual, vizinho))
        i = i + 1

      for noAdjacente in nosAdjacentes:
        for celulaVisitada in celulasVisitadas:
          if (celulaVisitada.pos == noAdjacente.pos) == True:
            jaVisitado.append(celulaVisitada.pos)

        if labirinto.labirintoArestas[noAdjacente.pos] != 0:
          if noAdjacente.pos not in jaVisitado:
            noAdjacente.h = matrizDist[noAdjacente.pos]
            fronteiraNode.append(noAdjacente)
            fronteira.append(noAdjacente.pos)

        for openNode in fronteiraNode:
          if noAdjacente == openNode:
            continue


  print("Objetivo nao existente no grafo")

"""## A*"""

def aStarSearch(labirinto):
  fronteiraNode = []
  fronteira = []
  caminhos = []
  celulasVisitadas = []
  statusLabirinto = []
  matrizDist = matrizDistanciaEuclidiana()

  fig, ax = plt.subplots()
  ims = []
  ims.append([ax.imshow(labirinto.getLabirintoPlot())])

  srcNode = Node(None, labirinto.getPosicaoInicio())
  destNode = Node(None, labirinto.getDestino())

  fronteiraNode.append(srcNode)
  fronteira.append(labirinto.getPosicaoInicio())

  while fronteiraNode != []:
    # Imprime Fronteira
    statusLabirinto.append(labirinto.getLabirintoPlot(posicoes=fronteira, cores=(0,255,127)))
    im = ax.imshow(statusLabirinto[len(statusLabirinto) - 1])
    ims.append([im])

    noAtual = fronteiraNode[0]
    indiceAtual = 0

    #Encontra o nó com a menor distancia
    for index, item in enumerate(fronteiraNode):
      if item.f < noAtual.f:
        noAtual = item
        indiceAtual = index

    fronteiraNode.pop(indiceAtual) # Selecionando o menor elemento da lista
    celulasVisitadas.append(noAtual)

    if noAtual.pos == destNode.pos:
      print("Objetivo", noAtual.pos, "encontrado")

      #Seleciona o caminho do nó inicial até o objetivo
      path = []
      current = noAtual
      while current is not None:
        path.append(current.pos)
        current = current.pai

      #Imprime animação para o caminho final
      caminhoEncontrado = path[::-1]
      statusLabirinto.append(labirinto.getLabirintoPlot(posicoes=caminhoEncontrado, cores=(0,0,255)))
      im = ax.imshow(statusLabirinto[len(statusLabirinto) - 1])
      ims.append([im])
      ani = animation.ArtistAnimation(fig, ims, interval=300, blit=True, repeat = True)
      plt.show()

      return path[::-1]

    else:
      vizinhos = getVizinhos(noAtual.pos)

      #BFS
      nosAdjacentes = []
      jaVisitado = []
      i = 0
      for vizinho in vizinhos:
        nosAdjacentes.append(Node(noAtual, vizinho))
        i = i + 1

      for noAdjacente in nosAdjacentes:

        for celulaVisitada in celulasVisitadas:
          if (celulaVisitada.pos == noAdjacente.pos) == True:
            jaVisitado.append(celulaVisitada.pos)

        if labirinto.labirintoArestas[noAdjacente.pos] != 0:
          if noAdjacente.pos not in jaVisitado:
            noAdjacente.g = noAtual.g + 1
            noAdjacente.h = matrizDist[noAdjacente.pos]
            noAdjacente.f = noAdjacente.g + noAdjacente.h
            fronteiraNode.append(noAdjacente)
            fronteira.append(noAdjacente.pos)

        for openNode in fronteiraNode:
          if noAdjacente == openNode and noAdjacente.g > openNode.g:
            continue

  print("Objetivo nao existente no grafo")

# Execução dos algoritmos de busca
labirinto = Labirinto(10)

def main():
    #labirinto = Labirinto(10)
    fig = plt.figure(figsize=(10,10))
    plt.imshow(labirinto.getLabirintoPlot())
    print("Digite 1 para executar a busca em largura")
    print("Digite 2 para executar a busca em profundidade")
    print("Digite 3 para executar a busca best first")
    print("Digite 4 para executar a busca A*")
    busca = input("Digite a opção desejada:")
    if busca == "1":
      buscaEmLargura(labirinto)
    elif busca == "2":
      buscaEmProfundidade(labirinto)
    elif busca == "3":
      bestFirst(labirinto)
    elif busca == "4":
      aStarSearch(labirinto)
    else:
      print("Opção inválida")


if __name__ == '__main__':
    main()

